library(datasets)
data(iris)
iris
lapply(iris,mean)
s <- split(iris,iris&Species)
iris["Species"]
s <- split(iris,iris$Species)
s
lapply(s, function(x),colmeans(x["Sepal.Length"]))
lapply(s, function(x) colMeans(x["Sepal.Length"]))
colMeans(iris)
apply(iris, 1, mean)
apply(iris[, 1:4], 2, mean)
apply(iris[, 1:4], 1, mean)
library(datasets)
data(mtcars)
?mtcars
tapply(mtcars$cyl, mtcars$mpg, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
tapply(mtcars$hp, mtcars$cyl, average)
tapply(mtcars$hp, mtcars$cyl, avg)
tapply(mtcars$hp, mtcars$cyl, mean)
209.21429 - 82.63636
ls
debug(ls)
ls
debug(lm)
lm(y - x)
0
exit
q
stop
undebug(lm)
debug(ls)
ls
ls
debug(ls)
ls
setwd("~/R/ProgrammingAssignment2/programmingassignment2")
ls
source("cachematrix.R")
cachematrix
cachesolve
cacheSolve
makeCacheMatrix
getwd()
mat <- matrix(1:4,2,2)
mat
cachesolve(mat)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cachesolve(mat)
cacheSolve(mat)
mat <- makeCacheMatrix()
mat
Class(mat)
class(mat)
class(mat&set)
class(mat$set)
mat$set(c(1,2,3,4))
mat$get()
cacheSolve(mat)
mat$set(matrix(1:4,2,2))
mat$get()
cacheSolve(mat)
## Caches the inverse of a matrix so that if the matrix does not change
## the inverse can be looked up from the cache instead of re-calculated
makeCacheMatrix <- function(x = matrix()) {
## creates a matrix that is used to store the cached inverse
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
## Calculates the inverse of the matrix, but first checks
## to see if the inverse has already been calculated.
## If so, it returns the cached value
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
